<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>MaskMain</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-3</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>MaskSquareTall</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*==============================================================================//
                        Setup settings for Sonic
//==============================================================================*/
    /* Changable settings */

    hspl                = 20;                    /* Horizontal Speed Limit */
    vspl                = 20;                    /* Vertical Speed Limit */

    acc                 = 0.11;                  /* Acceleration */
    max_runspeed        = 12;                    /* Maximum run speed */
    vfr                 = 0.3;                   /* Vertical Force (gravity) */
    rol_minsp           = 0.4;                   /* Minimum speed needed to roll */
    fric_nat            = 0.10;                  /* Natural Friction Value */
    fric_mov            = 0.005;                 /* Moving Friction Value */
    fric_rol            = 0.04;                  /* Rolling Friction Value (for slopes and the ground) */
    fric_gnd            = 0.21;                  /* Ground Friction Value (for slopes and the ground) */
    jmp                 = -6.8;                  /* Jump strength */
    spind               = 15;                    /* Spin dash strength */

    mask_radius         = 12;                    /* Radius of the player mask */
    character           = Sonic;                 /* Character sprite used */

//==============================================================================
    /* Key action mapping variables */
    KEY_LEFT        = false;
    KEY_RIGHT       = false;
    KEY_UP          = false;
    KEY_DOWN        = false;
    KEY_A_PRESS     = false;

//==============================================================================
    /* Variable initializations */  

    life                = 3;                     /* Number Of Lifes (should be set outside of the Player) */
    scores              = 0;                     /* The player score (should be set outside of the Player) */

    angle               = 0;                     /* Angle of the player*/
    dcos_val            = 1;                     /* Angle cos component */
    dsin_val            = 0;                     /* Amgle sin component */
    ground              = 1;                     /* Check if the player is on the ground */
    action              = 0;                     /* Action the player is currently doing */
    pushing             = 0;                     /* Whether pushing */
    jumping             = 0;                     /* Whether jumping */
    jump_factor         = -1;                    /* Used for variable jump height */
    balancing           = 0;                     /* Balancing direction (0 = not balancing) */
    xdir                = 1;                     /* Direction */
    fric                = 0;                     /* Friction */
    hsp                 = 0;                     /* Horizontal Speed */
    vsp                 = 0;                     /* Vertical Speed */
    full_hspeed         = 0;                     /* The full horizontal amount moving */
    full_vspeed         = 0;                     /* The full vertical amount moving */
    full_direction      = 0;                     /* The full direction moving in (in radians) */
    shield              = 0;                     /* Type of shield used (0 = none, 1 = basic, 2 = fire, 3 = electricity, 4 = water) */
    shield_action       = -1;                    /* Shield action (0 = not using, greater is counter for time used) */
    rings               = 0;                     /* Amount of rings */
    ring_life_counter   = 0;                     /* Amount of lifes taken from 100 rings */
    invincibility       = -1;                    /* Counter used in invinciblity timing and type (-1 = none, 0 = hit, 10000 = shield */
    sneekers            = -1;                    /* Counter for speed sneekers */
    invisible           = 0;                     /* Whether invisible or not */
    current_music       = -1;                    /* Current music playing */
    wait_time           = 0;                     /* Counter used in wait timing */
    time_count          = 0;                     /* Game time counter */
    current_step        = 0;                     /* Monitors the current step in the game */
    depth_layer         = -5;                    /* The current depth layer deactivated */
 
//==============================================================================
    /* Constants */
    act_none            = 0;
    act_roll            = 1;
    act_lookdown        = 2;
    act_lookup          = 3;
    act_spindash        = 4;
    act_spring          = 5;
    act_hit             = 6;
    act_death           = 7;

    inv_hit             = 0;
    inv_box             = 10000;
    inv_action          = 20000;

//==============================================================================
    /* Animation variables used in draw */
    animation           = -1;
    animations_old      = -1;
    animations_frame    = 0;
    animations_framemin = 0;
    animations_framemax = 0;
    animations_speed    = 0;
    animations_timer    = 0;
    animations_return   = 0;

    /* Animation constants */
    ani_stand               = 0;
    ani_wait_start          = 1;
    ani_wait_tap            = 2;
    ani_walk                = 3;
    ani_run                 = 4;
    ani_roll                = 5;
    ani_lookdown            = 6;
    ani_lookup              = 7;
    ani_spindash            = 8;
    ani_spring              = 9;
    ani_hit                 = 10;
    ani_death               = 11;
    ani_push                = 12;
    ani_brake               = 13;
    ani_balance_forwards    = 14;
    ani_balance_backwards   = 15;

    /* Animation settings */

    ani_framemin[ani_push]                  = 45;
    ani_framemax[ani_push]                  = 48;
    ani_return[ani_push]                    = 45;
    ani_speed[ani_push]                     = 10;

    ani_framemin[ani_balance_forwards]      = 51;
    ani_framemax[ani_balance_forwards]      = 52;
    ani_return[ani_balance_forwards]        = 51;
    ani_speed[ani_balance_forwards]         = 10;

    ani_framemin[ani_balance_backwards]     = 53;
    ani_framemax[ani_balance_backwards]     = 55;
    ani_return[ani_balance_backwards]       = 53;
    ani_speed[ani_balance_backwards]        = 10;

    ani_framemin[ani_stand]                 = 0;
    ani_framemax[ani_stand]                 = 0;
    ani_return[ani_stand]                   = 0;
    ani_speed[ani_stand]                    = 0;                  

    ani_framemin[ani_wait_start]            = 1;
    ani_framemax[ani_wait_start]            = 2;
    ani_return[ani_wait_start]              = 3;
    ani_speed[ani_wait_start]               = 5;

    ani_framemin[ani_wait_tap]              = 3;
    ani_framemax[ani_wait_tap]              = 4;
    ani_return[ani_wait_tap]                = 3;
    ani_speed[ani_wait_tap]                 = 10;

    ani_framemin[ani_brake]                 = 49;
    ani_framemax[ani_brake]                 = 50;
    ani_return[ani_brake]                   = 49;
    ani_speed[ani_brake]                    = 12;

    ani_framemin[ani_walk]                  = 5;
    ani_framemax[ani_walk]                  = 16;
    ani_return[ani_walk]                    = 5;
    ani_speed[ani_walk]                     = 12;

    ani_framemin[ani_run]                   = 17;
    ani_framemax[ani_run]                   = 23;
    ani_return[ani_run]                     = 17;
    ani_speed[ani_run]                      = 14;

    ani_framemin[ani_roll]                  = 24;
    ani_framemax[ani_roll]                  = 31;
    ani_return[ani_roll]                    = 24;
    ani_speed[ani_roll]                     = 14;

    ani_framemin[ani_lookdown]              = 32;
    ani_framemax[ani_lookdown]              = 33;
    ani_return[ani_lookdown]                = 33;
    ani_speed[ani_lookdown]                 = 20;
 
    ani_framemin[ani_lookup]                = 34;
    ani_framemax[ani_lookup]                = 35;
    ani_return[ani_lookup]                  = 35;
    ani_speed[ani_lookup]                   = 20;

    ani_framemin[ani_spindash]              = 36;
    ani_framemax[ani_spindash]              = 41;
    ani_return[ani_spindash]                = 36;
    ani_speed[ani_spindash]                 = 25;

    ani_framemin[ani_spring]                = 42;
    ani_framemax[ani_spring]                = 42;
    ani_return[ani_spring]                  = 42;
    ani_speed[ani_spring]                   = 0;

    ani_framemin[ani_hit]                   = 43;
    ani_framemax[ani_hit]                   = 43;
    ani_return[ani_hit]                     = 43;
    ani_speed[ani_hit]                      = 0;

    ani_framemin[ani_death]                 = 44;
    ani_framemax[ani_death]                 = 44;
    ani_return[ani_death]                   = 44;
    ani_speed[ani_death]                    = 0;

//==============================================================================
    /* Code execution */
    camera = instance_create(x, y, DisplayCamera);
    camera.xpan = 0;
    camera.ypan = 0;
    view_object = camera;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Game Motion</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Game Motion

    // If death action then to the death movement and disable rest of the step code
    if (action == act_death)
    {
        vsp += 0.3;
        y += vsp;
        if (y &gt; view_xview + view_hview + 250)   // Once player falls out below the view then restart the room (you can set lifes -= 1 here)
        {
            if (life == 0)
                game_end();
            else
                room_restart();
        }
        return 0;
    }


    // Limit the values of the movement
    if (abs(hsp) &gt; hspl)    hsp = sign(hsp)*hspl;
    if (abs(vsp) &gt; vspl)    vsp = sign(vsp)*vspl;

    //================================================================= 
    // Main horizontal and vertical movement, done by moving the player forward in increments of the hsp and vsp and checking if there is a collision

    var step_repeat, hstep, vstep, hsign, vsign, hstep_x, hstep_y, rmove, lmove, bmove, tmove;

    step_repeat = ceil(max(abs(hsp), abs(vsp)));

    hsign = sign(hsp);
    vsign = sign(vsp);
    done1 = (hsign == 0); done2 = (vsign == 0);
    rmove = (hsign == +1);
    lmove = (hsign == -1);
    bmove = (vsign == +1);
    tmove = (vsign == -1);

    if (step_repeat != 0)
    {
        hstep = hsp/step_repeat;
        vstep = vsp/step_repeat;
        hstep_x = dcos_val*hstep;
        hstep_y = dsin_val*hstep;
    }

    repeat (step_repeat)
    {
       if (!done1)
       {        
            if ((collision_sensor_right(MaskLarge) &amp;&amp; rmove) || (collision_sensor_left(MaskLarge) &amp;&amp; lmove))
            {
                done1 = true;
            }
            else
            {
                x += hstep_x;
                y -= hstep_y;
            }
        }
        if (!done2)
        {        
            if ((collision_sensor_bottom(MaskLarge) &amp;&amp; bmove) || (collision_sensor_top(MaskLarge) &amp;&amp; tmove))
            {
                done2 = true;
            }
            else
            {
                y += vstep;
            }
        }

        if (done1 &amp;&amp; done2) break;
    }

    if (tmove)
        if (collision_sensor_top(MaskLarge))
            vsp = 0;   // Stop vsp if hit under wall

    //=================================================================      
    // Landing. If we are falling and we landed, if the delimiter lines are colliding, search for new angle.
    if (vsp &gt;= 0 &amp;&amp;
       !ground &amp;&amp; 
       collision_sensor_bottom(MaskLarge) &amp;&amp;
       collision_sensor_right_line() &amp;&amp;
       collision_sensor_left_line())
    {
        angle = calculate_angle(0);
        dcos_val = cos(degtorad(angle));
        dsin_val = sin(degtorad(angle));
        if (shield == 4 &amp;&amp; shield_action != -1)     // If using the water shield then bounce
        {
            hsp = -vsp*dsin_val*0.75;
            vsp = -vsp*dcos_val*0.75;
            angle = 0;
            dcos_val = 1;
            dsin_val = 0;
            jumping = 1;
        }
        else
        {    
            hsp -= dsin_val*vsp;
            vsp = 0;
            ground = 1;

            jumping = 0;
            shield_action = -1;

             if (action == act_roll || action == act_spring || action == act_hit)
                action = act_none;       // Deactivate the rolling, springing or hit actions
        }
    }

    //=================================================================
    // Wall Collisions, if the side masks are colliding, move the player in order to avoid getting stuck.
    while (collision_sensor_right(MaskLarge))
    {
        x -= dcos_val;
        y += dsin_val;                                                                                        
    }

    while (collision_sensor_left(MaskLarge))
    {
        x += dcos_val;
        y -= dsin_val;                                                                                        
    }

    //=================================================================   
    // Do slopes while we're on the ground.
    if (ground)
    {
        // Slopes up: If the main sensor is colliding with the background, push to up
        while (collision_sensor_main())
        {
            x -= dsin_val;
            y -= dcos_val;  
        }

        // Slopes down: If the main sensor isn't colliding with the background but the slope sensor does, push to down.
        while (!collision_sensor_main() &amp;&amp; collision_sensor_slopes(MaskMedium))
        {
            x += dsin_val;
            y += dcos_val;  
        }
    }

    //=================================================================     
    if (ground)
    {
        // Check if the delimeter lines aren't colliding while we are on the ground, if that's true, get impulsed to the air
        if (!collision_sensor_left_line() || !collision_sensor_right_line())
        {
            vsp = -dsin_val*hsp;
            hsp = dcos_val*hsp;
            ground = 0;
            angle = 0;
            dcos_val = 1;
            dsin_val = 0;
        }

       // Or if the player is too slow and we're on the roof or on a wall, fall
       if (angle&gt;70 &amp;&amp; angle&lt;290 &amp;&amp; abs(hsp)&lt;5.5)
       {
            vsp = -dsin_val*hsp;
            hsp = dcos_val*hsp;
            ground = 0;
            angle = 0;
            dcos_val = 1;
            dsin_val = 0;

            if (action != act_roll)     // go into roll when falling off a wall
            {
                action = act_roll;
                sound_play(SndSpin);
            }
        }

        // Add momentum when rolling on slopes
        if (action == act_roll)
        {
            if ((angle &lt; 90 &amp;&amp; hsp &lt; acc) || (angle &gt; 270 &amp;&amp; hsp &gt; -acc)) // Accelerate down hills
               hsp += 1.2*acc*-dsin_val;
            if ((angle &gt; 15 &amp;&amp; angle &lt; 165 &amp;&amp; hsp &gt; acc) || (angle &gt; 195 &amp;&amp; angle &lt; 345 &amp;&amp; hsp &lt; -acc)) // Flick up curves
               hsp += abs(hsp)*dsin_val*0.005;
        }
    }

    //=================================================================   
    // After moving, get the new angle of the ground while the delimeter lines are colliding
    // and the player is on the ground.
    if (ground &amp;&amp; collision_sensor_left_line() &amp;&amp; collision_sensor_right_line())
    {
        if (hsp != 0 || vsp != 0)       // Only get a new angle if moving
        {
            angle = calculate_angle(angle);
            dcos_val = cos(degtorad(angle));
            dsin_val = sin(degtorad(angle));
        }
    }
    else
    {
        angle = 0;
        dcos_val = 1;
        dsin_val = 0;
    }

    // Now do vertical Movement.
    if (!ground)
    {
        // If we aren't on the ground and we are falling and the bottom sensor is colliding, land
        if (vsp &gt;= 0 &amp;&amp; collision_sensor_bottom(MaskLarge))
        {
            ground = 1;
            vsp = 0;
            if (action == act_roll || action == act_spring || action == act_hit) action =act_none;   // Deactivate rolling, springing and hit actions
        }
    }
    else
    {
        // Otherwise, if we are on the ground and the bottom sensor isn't colliding, fall.
        if (!collision_sensor_bottom(MaskLarge))    
        {
            ground = 0;
        }
    }

    if (!ground)
    {
        // Apply forces if we are falling
        vsp += vfr;
        if (vsp &gt; 0 &amp;&amp; action == act_spring)
            action = act_none;     // Stop spring action and change to falling  
    }

    if (action == act_roll)  // If action is rolling use a smaller square mask
    {
        sprite_index = MaskMain;
        mask_index = MaskSquareSmall;
    }
    else
    {
        sprite_index = MaskMain;
        mask_index = MaskSquareTall;
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Gameplay</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gameplay


    if (action == act_death)  // Death code handled in first code piece, but still need to exit this step code when dead
        return 0;
 
    // First, we query the keyboard and store the key data into the variables, for latter use.
    KEY_LEFT        = keyboard_check(vk_left);
    KEY_RIGHT       = keyboard_check(vk_right);
    KEY_UP          = keyboard_check(vk_up);
    KEY_DOWN        = keyboard_check(vk_down);
    KEY_A_PRESS     = keyboard_check_pressed(vk_space) || keyboard_check_pressed(ord('Z')) || keyboard_check_pressed(vk_control);  
    KEY_A           = keyboard_check(vk_space) || keyboard_check(ord('Z')) || keyboard_check(vk_control);

    // If the player pressed any direction, change
    if (action != act_spindash)
    {
        if (KEY_LEFT)
        {
            xdir=-1;
        }
        else if (KEY_RIGHT)
        {
            xdir=1;   
        }
    }

    // If the player is on the ground, we apply the deacceleration based on the actual angle
    if (ground)
    {
        hsp -= dsin_val*(fric_gnd);
    }

    if (action == act_roll || action == act_hit)
        fric = fric_rol;    // Less friction when rolling or hit
    else
        fric = fric_nat;    // Standard friction

    // Accelerate or deaccelerate if the player pressed the keys
    if (KEY_LEFT)
    {
        if (action == act_roll &amp;&amp; ground)
        {
            if (hsp &gt;= 0) hsp -= acc;                   // If the player pressed the left key and the player is rolling right on the ground, deaccelerate
        }
        else if (action != act_spindash &amp;&amp; action != act_lookup &amp;&amp; action != act_lookdown &amp;&amp; action != act_hit)
        {
            if (hsp &gt;= 0) hsp -= acc*4;                         // If the player pressed the left key and the player was moving to the right, deaccelerate faster
            if (hsp &lt; 0 &amp;&amp; hsp &gt; -max_runspeed) hsp -= acc;     // otherwise, do normal acceleration
            fric = fric_mov;                                    // Set natural friction lower when moving
        }
    }
    else if (KEY_RIGHT)                      
    {
        if (action == act_roll &amp;&amp; ground)
        {
            if (hsp &lt;= 0) hsp += acc;                   // Same for right when rolling on the ground
        }
        else if (action != act_spindash &amp;&amp; action != act_lookup &amp;&amp; action != act_lookdown &amp;&amp; action != act_hit)
        {
            if (hsp &lt;= 0) hsp += acc*4;                         // Same for the right, deaccelerate faster
            if (hsp &gt; 0 &amp;&amp; hsp &lt; max_runspeed) hsp += acc;      // or do normal acceleration
            fric = fric_mov;                                    // Set natural friction lower when moving
        }
    }

    // Natural Friction
    if (hsp &gt; 0) hsp -= fric;                     // While going to the right, deaccelerate friction amount
    if (hsp &lt; 0) hsp += fric;                     // While going to the left, deaccelerate friction amount

    if (hsp &gt; 0 &amp;&amp; hsp &lt; fric) hsp = 0;           // If the speed is lower than deacceleration, set to 0
    if (hsp &lt; 0 &amp;&amp; hsp &gt; -fric) hsp = 0;          // If the speed is lower than deacceleration, set to 0

    // Check for collisions on the sides. If those are true, set the speed to 0.
    var stood_still_on_fairly_flat_surface;
    stood_on_fairly_flat_surface = (ground &amp;&amp; action==act_none &amp;&amp; abs(((((angle - 0) mod 360) + 540) mod 360) - 180) &lt; 3);

    pushing = false;
    if (collision_sensor_right(MaskExtraLarge) &amp;&amp; hsp&gt;0)
    {
        hsp = 0;
        if (stood_on_fairly_flat_surface)
            pushing = true;
    }
    if (collision_sensor_left(MaskExtraLarge) &amp;&amp; hsp&lt;0)
    {
        hsp = 0;
        if (stood_on_fairly_flat_surface)
            pushing = true;
    }

    // Check for balancing when at platform edge
    balancing = 0;
    if (stood_on_fairly_flat_surface &amp;&amp; hsp == 0 &amp;&amp; vsp == 0)
    {
        if (!collision_sensor_right_line())
            balancing = 1;
        else if (!collision_sensor_left_line())
            balancing = -1;
    }

    if (jump_factor != -1)
    {
        if (KEY_A &amp;&amp; jump_factor &lt; 10)
        {
            hsp += jump_hsp/80;
            vsp += jump_vsp/40;
            jump_factor += 1;
        }
        else
        {
            jump_factor = -1;
        }
    }

    if (KEY_A_PRESS &amp;&amp; ground)
    {
        if (action == act_lookdown || action == act_spindash)  // If action is looking down then start Spin Dash
        {
            action = act_spindash;     // Set action to Spin Dash
            sound_play(SndDashCharge);
        }
        else  // Jump
        {
            vsp = dcos_val*jmp-dsin_val*hsp;
            hsp = dcos_val*hsp+dsin_val*jmp;

            // Default angle values
            ground = 0;
            angle = 0;     
            dcos_val = 1;
            dsin_val = 0;

            jumping = 1;             // Set jumping action variable
            jump_factor = 0;         // Used for variable jump height
            jump_vsp = vsp;
            jump_hsp = hsp;
            action = act_roll;       // Set action to rolling when jumping
            sound_play(SndJump);
        }
    }
    else
    {
        // Shields
        if (KEY_A_PRESS &amp;&amp; action = act_roll &amp;&amp; jumping == 1)
        {
            switch (shield)
            {

            case 0:
                if (invincibility == -1)
                    invincibility = inv_action;
                jumping = 0;
                sound_play(SndInvAction);
                break;

            case 2:
                sound_play(SndShieldFireAction);
                hsp = 15*xdir;
                shield_action = 0;
                jumping = 0;
                break;

            case 3:
                sound_play(SndShieldElectricityAction);
                hsp /= 2;
                vsp = -8;
                shield_xpos = x;    // x position for sparks
                shield_ypos = y;    // y position for sparks
                shield_action = 0;
                jumping = 0;
                break;

            case 4:
                sound_play(SndShieldWaterAction);
                hsp = 0;
                vsp = 12;
                shield_action = 0;
                jumping = 0;
                break;
            }
        }
    }
    
    if (ground &amp;&amp; abs(hsp) &lt; rol_minsp/2)
    {
        if (action==act_roll) action = act_none;     // Stop rolling if hardly moving
    }

    if (KEY_DOWN &amp;&amp; ground)
    {
        if (hsp == 0)
        {
            if (action == act_none) action = act_lookdown;      // Set action looking down
        }
        else if (abs(hsp) &gt; rol_minsp &amp;&amp; !KEY_LEFT &amp;&amp; !KEY_RIGHT &amp;&amp; action != act_roll)
        {
            action = act_roll;     // Start rolling
            sound_play(SndSpin);
        }
    }

    if (action == act_lookdown &amp;&amp; !KEY_DOWN)
    {
        action = act_none;     // Deactivate looking down if down is no longer being pressed
    }

    if (action == act_spindash &amp;&amp; !KEY_DOWN)
    {
        hsp=spind*xdir;             // Set spin dash in motion after releasing down
        action = act_roll;          // Start rolling when spin dashing
        sound_stop(SndDashCharge);
        sound_play(SndDashGo);
    }

    if (KEY_UP &amp;&amp; ground &amp;&amp; hsp == 0)
    {
        if (action == act_none) action = act_lookup;        // Set action looking up
    }

    if (action == act_lookup &amp;&amp; !KEY_UP)
    {
        action = act_none;     // Deactivate looking up if down is no longer being pressed
    }

    //=================================================================
    // Increase wait time when doing nothing
    if (action == act_none &amp;&amp; ground &amp; hsp == 0 &amp;&amp; vsp == 0 &amp;&amp; !pushing)
        wait_time += 1;
    else
        wait_time = 0;

    //=================================================================
    // Get the full hspeed, vspeed and direction of the Player as they would be used by the standard variables
    full_hspeed = hsp*dcos_val;
    full_vspeed = vsp-hsp*dsin_val;
    full_direction = arctan2(-full_vspeed, full_hspeed); // In radians

    //=================================================================   
    // Set the mask depending on the action

    if (action==act_roll)  // If action is rolling use a smaller square mask
    {
        sprite_index=MaskMain;
        mask_index=MaskSquareSmall;
    }
    else
    {
        sprite_index=MaskMain;
        mask_index=MaskSquareTall;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Time Counters</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Time Counter Codes

    // Invincibility code
    invisible = 0;
    if (invincibility != -1)
    {
        invincibility += 1;
        if (invincibility &lt; inv_box)            // Invincibility from being hit when not on invinciblity box counter
        {
            if (invincibility &gt; 200)                // Reset and disable invincibility again after 200 steps
                invincibility = -1;     

            if ((current_step div 6) mod 2 != 0)    // Exit the player draw every 6 steps to make it flash
                invisible = 1;
        }
        else if (invincibility &lt; inv_action)    // Now it's invincibility from box when not on invinciblity action counter
        {
            if (invincibility &gt; inv_box + 900)      // Reset and disable invincibility from box after 900 steps
            {
                invincibility = -1;
//                player_music(backing_music);      // Reset to backing_music (which you can add yourself)
            }
        }
        else                                    // Now it's the invinciblity action counter
        {
            if (invincibility &gt; inv_action + 6)
            {
                invincibility = -1;
            }            
        }
    }

    if (sneekers != -1)
    {
        sneekers += 1;
        if (sneekers &gt; 900)
        {
            sneekers = -1;
            acc = 0.1;
            max_runspeed = 12;
//                player_music(backing_music);      // Reset to backing_music (which you can add yourself)
        }
    }

    if (shield_action != -1)
    {
        shield_action += 1;
        if (shield_action &gt; 18)
            shield_action = -1;
    }</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Animation system</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation system

    switch (action)
    {

    // -&gt; Main animations when no action
    case act_none:
        if (ground)
        {
            if (hsp == 0)      // -&gt; Standing animations
            {
                if (pushing)
                {
                    animation = ani_push;
                }
                else if (balancing != 0)     // -&gt; Balancing animations
                {
                    if (balancing * xdir == 1)
                    {
                        animation = ani_balance_forwards;
                    }
                    else
                    {
                        animation = ani_balance_backwards;
                    }
                }
                else if (wait_time &lt; 660)
                {
                    animation = ani_stand;                
                }
                else if (animations_frame &lt; 3)
                {
                    animation = ani_wait_start;
                }
                else
                {
                    animation = ani_wait_tap;
                }
            }
            else    // -&gt; Moving animations
            {
                if ((animation == ani_brake || (abs(hsp) &gt; 8 &amp;&amp; abs(((((angle - 0) mod 360) + 540) mod 360) - 180) &lt; 15)) &amp;&amp; ((hsp &gt; 0 &amp;&amp; KEY_LEFT) || (hsp &lt; 0 &amp;&amp; KEY_RIGHT)))    // -&gt; Braking animation under the correct circumstances
                {
                    if (animation != ani_brake)
                        sound_play(SndBrake);
                    animation = ani_brake;
                }
                else if (abs(hsp) &lt; 8)
                {
                    animation = ani_walk;
                    animations_speed = ani_speed[ani_walk] + abs(hsp*3);
                }
                else
                {
                    animation = ani_run;
                    animations_speed = ani_speed[ani_run] + abs(hsp*2);
                }
            }
        }
        else    // Falling animation
        {
            animation = ani_walk;
            animations_speed = ani_speed[ani_walk] + abs(hsp*3);
        }
        break;

    case act_roll:
        animation = ani_roll;
        animations_speed = ani_speed[ani_roll] + abs(hsp*2);
        break;

    case act_lookdown:
        animation = ani_lookdown;
        break;

    case act_lookup:
        animation = ani_lookup
        break;

    case act_spindash:
        animation = ani_spindash;
        draw_sprite_ext(SpinSmoke, current_step mod 14, x, y, xdir, 1, 0, c_white, 0.8);  // Add smoke animation for spin dash
        break;

    case act_spring:
        animation = ani_spring;
        break;

    case act_hit:
        animation = ani_hit;
        break;
    
    case act_death:
        animation = ani_death;
        break;
    }
    
    //==========================================================
    // Core of the animation system

    // If animation changed, change to the new parameters...
    if (animation != animations_old)
    {
        animations_framemin = ani_framemin[animation];
        animations_framemax = ani_framemax[animation];
        animations_return = ani_return[animation];    
        animations_speed = ani_speed[animation];

        animations_frame = animations_framemin;
        animations_timer = 0;
        animations_old = animation;
    }

    // Add to the timer
    animations_timer += animations_speed

    if (animations_timer &gt;= 100)  // Check if we are ready to change of frame
    {    
        animations_timer = 0;
        animations_frame += 1;
        
        if (animations_frame &gt; animations_framemax)
        {
            animations_frame = animations_return;
        }
    }

    // Get angle of the animation
    if (action == act_spindash || pushing)
    {
        animations_angle = 0;
    }
    else if (ground || action == act_roll)
    {
        animations_angle = angle;
    }
    else if (animations_angle != 0)
    {
        if (animations_angle &lt;= 180)
        {
            animations_angle -= 8;
            if (animations_angle &lt; 0) animations_angle = 0;
        }
        else
        {
            animations_angle += 8;
            if (animations_angle &gt;= 360) animations_angle = 0;
        }    
    }</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Player Draw &amp; Shields</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player and shields

    var xpos, ypos;
    if (!invisible)
    {
        // Shield Position
        xpos = x + lengthdir_y(9, animations_angle);
        if (action == act_roll)
            ypos = y - lengthdir_x(4, animations_angle);
        else
            ypos = y - lengthdir_x(9, animations_angle);

        // Fire Shield Back
        if (shield == 2 &amp;&amp; shield_action == -1 &amp;&amp; invincibility == -1)
            draw_sprite_ext(SprShieldFire, 1 + (current_step div 4) * 2, xpos, ypos, xdir, 1, 0, c_white, 1);

        // Draw the character !!
        draw_sprite_ext(character, animations_frame, x, y, xdir, 1, animations_angle, c_white, 1);

        if (invincibility &gt;= inv_action)    //  Invincibility Action Effect
            draw_sprite_ext(SprInvAction, (invincibility - inv_action) - 1, xpos, ypos , xdir, 1, 0, c_white, 1);
        else if (invincibility &gt;= inv_box)
        {
            //  Invincibility Box Effect
            var i;
            repeat (2)
            {
                for (i = 0; i &lt; inv_sparks; i += 1)
                {
                
                    if (!inv_spark[i, 0])
                        break;
                }
                inv_spark[i, 0] = 1;                                // spark alive
                inv_spark[i, 1] = xpos + lengthdir_x(4, angle);     // spark x
                inv_spark[i, 2] = ypos + lengthdir_y(4, angle);     // spark y
                inv_spark[i, 3] = 5 + random(15);                   // spark radius
                inv_spark[i, 4] = random(360);                      // spark direction
                inv_spark[i, 5] = 0;                                // image_index
                inv_spark[i, 6] = 0;                                // spark steps
                
                if (i == inv_sparks)
                    inv_sparks += 1;
            }
              
            for (i = 0; i &lt; inv_sparks; i += 1)
            {
                if (!inv_spark[i, 0]) continue;
                
                if (inv_spark[i, 3] &lt; 20)
                    inv_spark[i, 3] += 0.25;

                inv_spark[i, 4] += 5;

                inv_spark[i, 5] += 1/8;
                if (inv_spark[i, 5] &gt;= 3.5)
                    inv_spark[i, 0] = 0;

                if (inv_spark[i, 6] &gt;= 15)
                    inv_spark[i, 0] = 0;
                inv_spark[i, 6] += 1;

                draw_sprite(SprInvincibility, inv_spark[i, 5], inv_spark[i, 1] + lengthdir_x(inv_spark[i, 3],inv_spark[i, 4]), inv_spark[i, 2] + lengthdir_y(inv_spark[i, 3], inv_spark[i, 4]))
            }
        }

        if (invincibility == -1)
        {
            // Shields
            switch (shield)
            {

            case 1:     // Basic Shield
                draw_sprite_ext(SprShieldBasic, current_step div 6, xpos, ypos, xdir, 1, 0, c_white, 1);
                break;

            case 2:     // Fire Shield Front
                if (shield_action == -1)
                    draw_sprite_ext(SprShieldFire, (current_step div 4) * 2, xpos, ypos, xdir, 1, 0, c_white, 1);
                else
                    draw_sprite_ext(SprShieldFireAction, current_step div 4, xpos, ypos, xdir, 1, 0, c_white, 1);
                break;

            case 3:     // Electricity Shield
                draw_sprite_ext(SprShieldElectricity, current_step div 5, xpos, ypos, xdir, 1, 0, c_white, 1);
                if (shield_action != -1) 
                {
                    draw_sprite_ext(SprShieldElectricityAction, (shield_action - 1) div (18/4), shield_xpos + 25 + shield_action*3, shield_ypos - 16 + shield_action/10, 1, 1, 0, c_white, 1);
                    draw_sprite_ext(SprShieldElectricityAction, (shield_action - 1) div (18/4), shield_xpos - 25 - shield_action*3, shield_ypos - 16 + shield_action/10, 1, 1, 0, c_white, 1);
                    draw_sprite_ext(SprShieldElectricityAction, (shield_action - 1) div (18/4), shield_xpos + 25 + shield_action*3, shield_ypos + 35 + shield_action*3, 1, 1, 0, c_white, 1);
                    draw_sprite_ext(SprShieldElectricityAction, (shield_action - 1) div (18/4), shield_xpos - 25 - shield_action*3, shield_ypos + 35 + shield_action*3, 1, 1, 0, c_white, 1);
                }
                break;

            case 4:     // Water Shield
                if (shield_action == -1)
                    draw_sprite_ext(SprShieldWater, current_step div 4, xpos, ypos, xdir, 1, 0, c_white, 1);
                else
                    draw_sprite_ext(SprShieldWaterAction, 0, xpos, ypos, xdir, 1, 0, c_white, 1);
                break;
            }
        }
    }</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
